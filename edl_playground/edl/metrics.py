import torch
from torch import Tensor
from torchmetrics import Metric


from .losses import get_uncertainty_matrix


class UncertaintyMatrix(Metric):
    def __init__(self, uncertainty_thresh: float, **kwargs):
        super().__init__(**kwargs)
        self.uncertainty_thresh = uncertainty_thresh
        self.add_state("mtx", default=torch.zeros(4), dist_reduce_fx="sum")

    def update(self, evidence: Tensor, target: Tensor) -> None:
        self.mtx += torch.tensor(get_uncertainty_matrix(evidence, target, self.uncertainty_thresh), dtype=self.mtx.dtype, device=self.mtx.device)

    def compute(self) -> Tensor:
        return self.mtx


def get_probs(evidence):
    """Calculates expected probability for EDL based on https://arxiv.org/abs/1806.01768

    Args:
        evidence (e): evidence vector generated by NN (N, K) = (<#BATCHES>, <#CLASSES>), non-negative (activation already applied to model output)

    Returns:
        probs (p): Expected probability for each class (N, K)
    """
    alpha = evidence + 1 # (N, K)
    S = torch.sum(alpha, dim=1) # (N)
    probs = alpha / S[:, None] # (N, K) / (N) = (N, K)
    return probs
